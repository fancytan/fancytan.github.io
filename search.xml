<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2019/01/28/Nginx%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E7%AC%AC%E4%B8%80%E5%9B%9E%E5%90%88%EF%BC%89/"/>
      <url>/2019/01/28/Nginx%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E7%AC%AC%E4%B8%80%E5%9B%9E%E5%90%88%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Nginx入门学习（第一回合）"><a href="#Nginx入门学习（第一回合）" class="headerlink" title="Nginx入门学习（第一回合）"></a>Nginx入门学习（第一回合）</h1><p>[^开发者]:  由俄罗斯的程序设计师Igor Sysoev所开发</p><p>[TOC]</p><h2 id="一、产生背景"><a href="#一、产生背景" class="headerlink" title="一、产生背景"></a>一、产生背景</h2><p>1.巨大流量—海量的并发访问</p><p>2.单台服务器资源和能力有限</p><p>引发服务器宕机而无法提供服务</p><h2 id="二、负载均衡-Load-Balance"><a href="#二、负载均衡-Load-Balance" class="headerlink" title="二、负载均衡(Load Balance)"></a>二、负载均衡(Load Balance)</h2><h3 id="1、高并发"><a href="#1、高并发" class="headerlink" title="1、高并发"></a>1、高并发</h3><p>（1）、高（大量的）</p><p>（2）、并发就是可以使用多个线程或者多个进程，同时处理（就是并发）不同的操作</p><p>（3）、简而言之就是每秒内有多少个请求同时访问。</p><h3 id="2、负载均衡"><a href="#2、负载均衡" class="headerlink" title="2、负载均衡"></a>2、负载均衡</h3><p>（1）、将请求/数据【均匀】分摊到多个操作单元上执行</p><p>（2）、关键在于【均匀】,也是分布式系统架构设计中必须考虑的因素之一。</p><h3 id="3、互联网分布式架构"><a href="#3、互联网分布式架构" class="headerlink" title="3、互联网分布式架构"></a>3、互联网分布式架构</h3><p>常见，分为客户端层、反向代理nginx层、站点层、服务层、数据层。只需要实现“将请求/数据 均匀分摊到多个操作单元上执行”，就能实现负载均衡。</p><h2 id="三、对Nginx的基本了解"><a href="#三、对Nginx的基本了解" class="headerlink" title="三、对Nginx的基本了解"></a>三、对Nginx的基本了解</h2><h3 id="1、什么是Nginx？"><a href="#1、什么是Nginx？" class="headerlink" title="1、什么是Nginx？"></a>1、什么是Nginx？</h3><pre class=" language-txt"><code class="language-txt">  一款轻量级的Web 服务器/反向代理服务器【后面有介绍】及电子邮件（IMAP/POP3）代理服务器。</code></pre><p>​     <code>特点</code></p><pre><code>  *是占有内存少，CPU、内存等资源消耗却非常低，  *运行非常稳定并发能力强，nginx的并发能力确实在同类型的网页服务器中表现非常好。</code></pre><h3 id="2、Nginx-VS-Apache"><a href="#2、Nginx-VS-Apache" class="headerlink" title="2、Nginx   VS   Apache"></a>2、Nginx   VS   Apache</h3><h1 id="（1）、nginx相对于apache的优点："><a href="#（1）、nginx相对于apache的优点：" class="headerlink" title="（1）、nginx相对于apache的优点："></a>（1）、nginx相对于apache的优点：</h1><pre class=" language-txt"><code class="language-txt">*轻量级，同样起web 服务，比apache 占用更少的内存及资源高并发，*nginx 处理请求是异步非阻塞（如前端ajax）的，而apache 则是阻塞型的，*在高并发下nginx能保持低资源低消耗高性能高度模块化的设计，编写模块相对简单*Nginx 配置简洁, Apache 复杂</code></pre><h1 id="（2）、apache-相对于nginx-的优点："><a href="#（2）、apache-相对于nginx-的优点：" class="headerlink" title="（2）、apache 相对于nginx 的优点："></a>（2）、apache 相对于nginx 的优点：</h1><pre class=" language-txt"><code class="language-txt"> * Rewrite重写 ，比nginx 的rewrite 强大模块超多， *基本想到的都可以找到少bug ，nginx 的bug 相对较多。（出身好起步高）</code></pre><h2 id="四、安装Nginx"><a href="#四、安装Nginx" class="headerlink" title="四、安装Nginx"></a>四、安装Nginx</h2><p><code>这里以安装tengine为例</code></p><h3 id="1、安装之前准备"><a href="#1、安装之前准备" class="headerlink" title="1、安装之前准备"></a>1、安装之前准备</h3><p>配置依赖 gcc openssl-devel pcre-devel zlib-devel</p><p> 安装：</p><blockquote><p>yum install gcc openssl-devel pcre-devel zlib-devel -y</p></blockquote><h3 id="2、下载"><a href="#2、下载" class="headerlink" title="2、下载"></a>2、下载</h3><p>（目前最新版）：<a href="http://tengine.taobao.org/download.html" target="_blank" rel="noopener">tengine-2.2.3.tar</a></p><h3 id="3、-解压缩"><a href="#3、-解压缩" class="headerlink" title="3、 解压缩"></a>3、 解压缩</h3><blockquote><p>tar  -zvxf   tengine-2.2.3.tar </p></blockquote><h3 id="4、安装Nginx"><a href="#4、安装Nginx" class="headerlink" title="4、安装Nginx"></a>4、安装Nginx</h3><blockquote><p>在Nginx解压的目录下运行：</p><p>./configure</p><p>make &amp;&amp; make install</p></blockquote><p>默认安装目录：<br>/usr/local/nginx</p><h3 id="5、配置Nginx为系统服务，以方便管理"><a href="#5、配置Nginx为系统服务，以方便管理" class="headerlink" title="5、配置Nginx为系统服务，以方便管理"></a>5、配置Nginx为系统服务，以方便管理</h3><h4 id="（1）、在-etc-rc-d-init-d-目录中建立文本文件nginx"><a href="#（1）、在-etc-rc-d-init-d-目录中建立文本文件nginx" class="headerlink" title="（1）、在/etc/rc.d/init.d/目录中建立文本文件nginx"></a>（1）、在/etc/rc.d/init.d/目录中建立文本文件nginx</h4><h4 id="（2）、在文件中粘贴下面的内容："><a href="#（2）、在文件中粘贴下面的内容：" class="headerlink" title="（2）、在文件中粘贴下面的内容："></a>（2）、在文件中粘贴下面的内容：</h4><pre class=" language-txt"><code class="language-txt">#!/bin/sh## nginx - this script starts and stops the nginx daemon## chkconfig:   - 85 15 # description:  Nginx is an HTTP(S) server, HTTP(S) reverse \#               proxy and IMAP/POP3 proxy server# processname: nginx# config:      /etc/nginx/nginx.conf# config:      /etc/sysconfig/nginx# pidfile:     /var/run/nginx.pid# Source function library.. /etc/rc.d/init.d/functions# Source networking configuration.. /etc/sysconfig/network# Check that networking is up.[ "$NETWORKING" = "no" ] && exit 0nginx="/usr/local/nginx/sbin/nginx"prog=$(basename $nginx)NGINX_CONF_FILE="/usr/local/nginx/conf/nginx.conf"[ -f /etc/sysconfig/nginx ] && . /etc/sysconfig/nginxlockfile=/var/lock/subsys/nginxmake_dirs() {   # make required directories   user=`nginx -V 2>&1 | grep "configure arguments:" | sed 's/[^*]*--user=\([^ ]*\).*/\1/g' -`   options=`$nginx -V 2>&1 | grep 'configure arguments:'`   for opt in $options; do       if [ `echo $opt | grep '.*-temp-path'` ]; then           value=`echo $opt | cut -d "=" -f 2`           if [ ! -d "$value" ]; then               # echo "creating" $value               mkdir -p $value && chown -R $user $value           fi       fi   done}start() {    [ -x $nginx ] || exit 5    [ -f $NGINX_CONF_FILE ] || exit 6    make_dirs    echo -n $"Starting $prog: "    daemon $nginx -c $NGINX_CONF_FILE    retval=$?    echo    [ $retval -eq 0 ] && touch $lockfile    return $retval}stop() {    echo -n $"Stopping $prog: "    killproc $prog -QUIT    retval=$?    echo    [ $retval -eq 0 ] && rm -f $lockfile    return $retval}restart() {    configtest || return $?    stop    sleep 1    start}reload() {    configtest || return $?    echo -n $"Reloading $prog: "    killproc $nginx -HUP    RETVAL=$?    echo}force_reload() {    restart}configtest() {  $nginx -t -c $NGINX_CONF_FILE}rh_status() {    status $prog}rh_status_q() {    rh_status >/dev/null 2>&1}case "$1" in    start)        rh_status_q && exit 0        $1        ;;    stop)        rh_status_q || exit 0        $1        ;;    restart|configtest)        $1        ;;    reload)        rh_status_q || exit 7        $1        ;;    force-reload)        force_reload        ;;    status)        rh_status        ;;    condrestart|try-restart)        rh_status_q || exit 0            ;;    *)        echo $"Usage: $0 {start|stop|status|restart|condrestart|try-restart|reload|force-reload|configtest}"        exit 2esac</code></pre><h4 id="（3）、修改nginx文件的执行权限"><a href="#（3）、修改nginx文件的执行权限" class="headerlink" title="（3）、修改nginx文件的执行权限"></a>（3）、修改nginx文件的执行权限</h4><blockquote><p>chmod +x nginx</p></blockquote><h4 id="（4）、添加该文件到系统服务中去"><a href="#（4）、添加该文件到系统服务中去" class="headerlink" title="（4）、添加该文件到系统服务中去"></a>（4）、添加该文件到系统服务中去</h4><blockquote><p>chkconfig –add nginx</p></blockquote><p>查看是否添加成功</p><blockquote><p>chkconfig –list nginx</p></blockquote><p>启动，停止，重新装载</p><blockquote><p>service nginx start|stop</p></blockquote><h2 id="五、Nginx配置"><a href="#五、Nginx配置" class="headerlink" title="五、Nginx配置"></a>五、Nginx配置</h2><h3 id="1、查看配置"><a href="#1、查看配置" class="headerlink" title="1、查看配置"></a>1、查看配置</h3><blockquote><p>cd   /usr/local/nginx/conf</p><p>vim   nginx.conf</p></blockquote><h3 id="2、配置解析"><a href="#2、配置解析" class="headerlink" title="2、配置解析"></a>2、配置解析</h3><pre class=" language-txt"><code class="language-txt">#进程数，建议设置和CPU个数一样或2倍worker_processes  2;#日志级别error_log  logs/error.log  warning;(默认error级别)# nginx 启动后的pid 存放位置#pid        logs/nginx.pid;events {    #配置每个进程的连接数，总的连接数= worker_processes * worker_connections    #默认1024    worker_connections  10240;}http {    include       mime.types;    default_type  application/octet-stream;    sendfile        on;#连接超时时间，单位秒keepalive_timeout  65;    server {        listen       80;        server_name  localhost                         #默认请求          location / {                     root  html;   #定义服务器的默认网站根目录位置                     index  index.php index.html index.htm;  #定义首页索引文件的名称        }        #定义错误提示页面        error_page   500 502 503 504  /50x.html;        location = /50x.html {            root   html;        }</code></pre><h3 id="3、负载均衡配置"><a href="#3、负载均衡配置" class="headerlink" title="3、负载均衡配置"></a>3、负载均衡配置</h3><p>安装Tomcat，参考 <code>Tomcat配置</code></p><h4 id="多负载均执行一下操作："><a href="#多负载均执行一下操作：" class="headerlink" title="多负载均执行一下操作："></a>多负载均执行一下操作：</h4><p> 多负载的情况下，打开指定虚拟机器</p><blockquote><p>open  node01    </p><p>node01  为指定虚拟机器的别名，在hosts文件中配置的</p></blockquote><p>启动Tomcat</p><blockquote><p>在Tomcat解压的目录下       ./startup.sh  </p></blockquote><p>注意： 记得关闭虚拟机器的防火墙</p><blockquote><p>service  iptables  stop</p></blockquote><p>浏览器访问</p><blockquote><p>虚拟机器IP地址：8080</p></blockquote><p>默认负载均衡配置</p><blockquote><pre><code>http {     upstream shsxt{       # 以下均为实际执行服务的服务器    #只有当hosts文件中给ip地址配置了别名，这里server后面才能用别名，    #否则跟IP地址        server node01;         server node02;         server node03;     }     server {     #指定访问端口为80 ，那么Tomcat服务器端的port也要改为80        listen 80;           server_name  localhost;        location / {            proxy_pass http://shsxt;                # shsxt  是指定的代理服务器        }    } }</code></pre></blockquote><p>配置文件编辑结束后，启动nginx服务</p><blockquote><p>service  nginx  start</p></blockquote><h4 id="（1）、轮询负载均衡（默认）"><a href="#（1）、轮询负载均衡（默认）" class="headerlink" title="（1）、轮询负载均衡（默认）"></a>（1）、轮询负载均衡（默认）</h4><pre><code> - 对应用程序服务器的请求以循环方式分发</code></pre><h4 id="（2）、加权负载均衡"><a href="#（2）、加权负载均衡" class="headerlink" title="（2）、加权负载均衡"></a>（2）、加权负载均衡</h4><blockquote><p>通过使用服务器权重，还可以进一步影响nginx负载均衡算法，</p><p>谁的权重越大，分发到的请求就越多。</p><p>权重总数：10</p></blockquote><p>在nginx.conf文件中修改：</p><pre><code> upstream shsxt {        server srv1.example.com weight=3;        server srv2.example.com;        server srv3.example.com;  }</code></pre><p>配置修改之后，重启</p><blockquote><p>service  nginx  restart</p></blockquote><h4 id="（3）、最少连接负载平衡"><a href="#（3）、最少连接负载平衡" class="headerlink" title="（3）、最少连接负载平衡"></a>（3）、最少连接负载平衡</h4><blockquote><p>在连接负载最少的情况下，nginx会尽量避免将过多的请求分发给繁忙的应用程序服务器，</p><p>而是将新请求分发给不太繁忙的服务器，避免服务器过载。</p></blockquote><p>在nginx.conf文件中修改：</p><pre><code>upstream shsxt {        least_conn;        server srv1.example.com;        server srv2.example.com;        server srv3.example.com;    }</code></pre><h4 id="（4）、会话持久性——ip-hash负载平衡机制"><a href="#（4）、会话持久性——ip-hash负载平衡机制" class="headerlink" title="（4）、会话持久性——ip-hash负载平衡机制"></a>（4）、会话持久性——ip-hash负载平衡机制</h4><p><code>特点</code>：保证相同的客户端总是定向到相同的服务;</p><p>(此方法可确保来自同一客户端的请求将始终定向到同一台服务器，除非此服务器不可用。)</p><p>在nginx.conf文件中修改：</p><pre><code>upstream shsxt{    ip_hash;    server （IP地址|别名）;    server （IP地址|别名）;    server （IP地址|别名）;}</code></pre><h4 id="5-、Nginx的访问控制"><a href="#5-、Nginx的访问控制" class="headerlink" title="(5)、Nginx的访问控制"></a>(5)、Nginx的访问控制</h4><blockquote><p>Nginx还可以对IP的访问进行控制，allow代表允许，deny代表禁止.</p></blockquote><pre><code>location / {deny 192.168.2.180;allow 192.168.78.0/24;allow 10.1.1.0/16;allow 192.168.1.0/32;deny all;proxy_pass http://shsxt;}</code></pre><pre><code>从上到下的顺序，匹配到了便跳出。如上的例子先禁止了1个，接下来允许了3个网段，其中包含了一个ipv6，最后未匹配的IP全部禁止访问</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/01/28/Linux%20%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E7%AC%AC%E4%BA%8C%E5%9B%9E%E5%90%88%EF%BC%89/"/>
      <url>/2019/01/28/Linux%20%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E7%AC%AC%E4%BA%8C%E5%9B%9E%E5%90%88%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-入门学习（第二回合）"><a href="#Linux-入门学习（第二回合）" class="headerlink" title="Linux 入门学习（第二回合）"></a>Linux 入门学习（第二回合）</h1><p><code>2018年12月18日  周二  晴</code></p><p><strong>今日学习要点：</strong></p><p>[TOC]</p><h2 id="Linux后半程"><a href="#Linux后半程" class="headerlink" title="Linux后半程"></a>Linux后半程</h2><h3 id="一、Linux系统配置"><a href="#一、Linux系统配置" class="headerlink" title="一、Linux系统配置"></a>一、Linux系统配置</h3><h4 id="1-主机名配置："><a href="#1-主机名配置：" class="headerlink" title="1.主机名配置："></a>1.主机名配置：</h4><blockquote><p>vim  /etc/sysconfig/network</p></blockquote><p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1545214876278.png" alt="1545214876278"></p><p>配置完成之后需要重启机器才能生效</p><blockquote><p>reboot</p></blockquote><h4 id="2-DNS配置"><a href="#2-DNS配置" class="headerlink" title="2.DNS配置"></a>2.DNS配置</h4><blockquote><h1 id="查看DNS服务器的地址"><a href="#查看DNS服务器的地址" class="headerlink" title="查看DNS服务器的地址"></a>查看DNS服务器的地址</h1><p>cat  /etc/resolv.conf</p><h1 id="修改DNS服务器地址"><a href="#修改DNS服务器地址" class="headerlink" title="修改DNS服务器地址"></a>修改DNS服务器地址</h1><p>方式一：vim  /etc/sysconfig/network.scripts/ifconfig-eth0</p><p>​             在配置网关时，配置DNS1=114.114.114.114（不推荐，江苏南京的IP）</p><p>方式二：vim   /etc/resolv.conf    （用本地网关解析）</p><p>​              nameserver   192.168.198.0   ( 此为虚拟机中的网关地址)</p></blockquote><h4 id="3-环境变量"><a href="#3-环境变量" class="headerlink" title="3.环境变量"></a>3.环境变量</h4><blockquote><p>配置系统环境变量，使得某些命令在执行时，系统可以找到命令对应的执行程序，命令才能正常执行。</p></blockquote><p>查看系统一共在哪些目录里寻找命令对应的程序</p><blockquote><p>命令：echo $PATH</p></blockquote><p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1545215894631.png" alt="1545215894631"></p><p><code>注意</code>：路径之间有冒号隔开，系统会从左往右依次寻找对应的程序</p><p>​             一般命令会存放在  bin目录，或sbin目录</p><p>配置全局环境变量：</p><blockquote><p>vim  /etc/profile</p><p>在文件中：</p><p>PATH=$PATH:(命令所在目录)</p><p>退出文件编辑后：</p><p>source  /etc/profile  </p><p> (重新加载资源，有的可能需要重启机器，这不适用于实际状况)</p></blockquote><p>配置局部环境变量：（推荐，限当前登录用户使用）</p><blockquote><p>查看所有文件(root目录下)</p><p>ls  -a    (发现隐藏文件    .bash.profile)</p><p>vim  ~/ bash_profile</p><p>在文件中：</p><p>export  PATH =$PATH:(命令所在目录)</p></blockquote><h4 id="4-拍快照"><a href="#4-拍快照" class="headerlink" title="4.拍快照"></a>4.拍快照</h4><p>（保存当时计算机所出状态的各种配置和资源，适度使用）</p><blockquote><p>选中指定虚拟计算机——鼠标右击—–选中“快照” ——“拍摄快照‘—-在页面中找到”拍摄快照“，并添加名称和描述</p><p>也可以删除，找到页面中的删除按钮</p></blockquote><h3 id="二、服务操作"><a href="#二、服务操作" class="headerlink" title="二、服务操作"></a>二、服务操作</h3><h4 id="1、查询操作系统"><a href="#1、查询操作系统" class="headerlink" title="1、查询操作系统"></a>1、查询操作系统</h4><p>在每一个执行等级中会执行哪些系统服务，其中包括各类常驻服务。</p><blockquote><p>命令：chkconfig</p></blockquote><p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1545219619458.png" alt="1545219619458"></p><pre class=" language-txt"><code class="language-txt">各数字代表的系统初始化级别：    0：停机状态　　1：单用户模式，root账户进行操作　　2：多用户，不能使用net file system，一般很少用　　3：完全多用户，一部分启动，一部分不启动，命令行界面　　4：未使用、未定义的保留模式　　5：图形化，3级别中启动的进程都启动，并且会启动一部分图形界面进程。　　6：停止所有进程，卸载文件系统，重新启动(reboot)</code></pre><blockquote><p>1、2、4很少用，0、3、5、6常用，3级别和5级别除了桌面相关的进程外没有什么区别，推荐都用3级别；</p><p>linux默认级别为3；</p><p>不要把 /etc/inittab  中 initdefault 设置为0 和 6； </p></blockquote><h4 id="2、服务操作"><a href="#2、服务操作" class="headerlink" title="2、服务操作"></a>2、服务操作</h4><blockquote><p>service 服务名 start/stop/status/restart</p></blockquote><p>举例：对防火墙服务进行操作</p><blockquote><p>防火墙的服务名为：iptables</p></blockquote><p>查看防火墙服务运行状态</p><blockquote><p>service  iptables status</p></blockquote><p>关闭防火墙</p><blockquote><p>service  iptables stop</p></blockquote><p>开启防火墙</p><blockquote><p>service  iptables start</p></blockquote><p>永久开启/关闭防火墙</p><blockquote><p>chkconfig iptables on/off</p></blockquote><h4 id="3、服务初执行等级更改"><a href="#3、服务初执行等级更改" class="headerlink" title="3、服务初执行等级更改"></a>3、服务初执行等级更改</h4><blockquote><p>chkconfig –level 2345 <code>name</code> off|on<br>                                   （ <code>服务名</code>）</p><p>举例：防火墙</p><p>chkconfig –level 2345 iptables   off</p></blockquote><p>若不加级别，默认是2345级别</p><blockquote><p>命令：chkconfig <code>name</code> on|off<br>                         （<code>服务名</code>）</p></blockquote><h3 id="三、linux进程操作"><a href="#三、linux进程操作" class="headerlink" title="三、linux进程操作"></a>三、linux进程操作</h3><h4 id="1、查看所有进程"><a href="#1、查看所有进程" class="headerlink" title="1、查看所有进程"></a>1、查看所有进程</h4><blockquote><p>命令： ps  -aux</p></blockquote><pre class=" language-txt"><code class="language-txt">    -a 列出所有    -u 列出用户    -x 详细列出，如cpu、内存等     -e select all processes    相当于-a     -f does full-format listing   将所有格式详细列出来      </code></pre><p>查看所有进程里CMD是ssh 的进程信息（包括pid 进程号）</p><blockquote><p>命令： ps  - ef | grep ssh      </p><p>（|  管道符  ：前一个输出，变为后一个的输入）</p><p>举例：</p><p>ps -ef | grep redis</p></blockquote><h4 id="2、杀死进程"><a href="#2、杀死进程" class="headerlink" title="2、杀死进程"></a>2、杀死进程</h4><p><code>kill</code></p><blockquote><p>命令：kill pid </p><p>-9    强制杀死</p><p>用法：用ps 命令先查出对应程序的PID或PPID ，然后用kill杀死掉进程。</p></blockquote><h3 id="四、其他常用命令"><a href="#四、其他常用命令" class="headerlink" title="四、其他常用命令"></a>四、其他常用命令</h3><h4 id="1、yum"><a href="#1、yum" class="headerlink" title="1、yum"></a>1、<strong>yum</strong></h4><table><thead><tr><th>基于<a href="https://baike.baidu.com/item/RPM" target="_blank" rel="noopener">RPM</a>包管理</th></tr></thead><tbody><tr><td>能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装</td></tr></tbody></table><p>跟换yum下载源（默认是到国外网站下载）</p><p>第一步：备份你的原镜像文件，以免出错后可以恢复</p><blockquote><p>cp /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</p></blockquote><p>第二步：下载新的CentOS-Base.rep到/etc/yum.repos.d/</p><blockquote><p>wget -O /etc/yum.repos.d/CentOS-Base.repo <a href="http://mirrors.aliyun.com/repo/Centos-6.repo" target="_blank" rel="noopener">http://mirrors.aliyun.com/repo/Centos-6.repo</a></p></blockquote><p>下载完之后，查看一下文件内容</p><blockquote><p>vim  /etc/yum.repos.d/CentOS-Base.repo</p></blockquote><p>第三步：生成缓存</p><blockquote><p>运行yum makecache</p></blockquote><p>查看当前源</p><blockquote><p>yum list | head -50</p></blockquote><h4 id="2、-wget"><a href="#2、-wget" class="headerlink" title="2、 wget"></a>2、 <strong>wget</strong></h4><table><thead><tr><th>一个从网络上自动下载文件的自由工具</th></tr></thead><tbody><tr><td>支持通过 HTTP、HTTPS、FTP 三个最常见的 TCP/IP协议，可以使用 HTTP 代理</td></tr></tbody></table><p>安装：</p><blockquote><p>yum install wget  –y</p></blockquote><p>用法：</p><blockquote><p>wget  [option] 网址  -O    指定下载保存的路径</p><p>举例：</p><p>wget  <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a>  -O baidu.html</p></blockquote><h4 id="3、tar"><a href="#3、tar" class="headerlink" title="3、tar"></a>3、<strong>tar</strong></h4><pre class=" language-txt"><code class="language-txt">    -z    gzip进行解压或压缩，带.gz需要加，压缩出来.gz也需要加    -x    解压    -c    压缩    -f    目标文件，压缩文件新命名或解压文件名    -v    解压缩过程信息打印</code></pre><blockquote><p>解压命令：tar  -zvxf  xxxx.tar.gz</p></blockquote><blockquote><p>压缩命令：tar -zcf 压缩包命名 压缩目标<br>举例：</p><p>tar -zcf  tomcat.tar.gz  apache-tomcat-7.0.61<br>将 apache-tomcat-7.0.61 目录压缩成tomcat.tar.gz包</p></blockquote><h4 id="4、man"><a href="#4、man" class="headerlink" title="4、man"></a>4、<strong>man</strong></h4><p>作用：用于查看指定命令的具体解释</p><p>安装</p><blockquote><p>yum install  man  -y</p><p>(下载并安装man  并确认)</p></blockquote><p>使用</p><blockquote><p>man  ps</p></blockquote><h3 id="五、JDK部署"><a href="#五、JDK部署" class="headerlink" title="五、JDK部署"></a>五、JDK部署</h3><h4 id="1、准备JDK安装包："><a href="#1、准备JDK安装包：" class="headerlink" title="1、准备JDK安装包："></a>1、准备JDK安装包：</h4><p>（这是使用   .rpm  格式的安装包）</p><p>官网下载：<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a></p><p>云盘资源：  <a href="https://pan.baidu.com/s/1LzeQbOnG9PROZrtlbYHlDg" target="_blank" rel="noopener">jdk-8u191-linux-x64.rpm</a>  ：</p><p>​     根据用户喜好放到虚拟机器的文件目录中</p><h4 id="2、解压并安装，展示编译过程"><a href="#2、解压并安装，展示编译过程" class="headerlink" title="2、解压并安装，展示编译过程"></a>2、解压并安装，展示编译过程</h4><blockquote><p>rpm   -ivh  jdk-8u191-linux-x64.rpm</p></blockquote><p>安装放到了 /usr 目录下，有/java目录</p><h4 id="3、配置环境变量"><a href="#3、配置环境变量" class="headerlink" title="3、配置环境变量"></a>3、配置环境变量</h4><blockquote><p>vim  ~/.bash_profile</p><p>在文件中：</p><p>JAVA_HOME=(jdk文件所在的路径+jdk文件名)</p><p>export  PATH=$PATH:$JAVA_HOME/bin</p></blockquote><p>注意：</p><p>新的path路径必须要包含旧的PATH路径，且每个路径之间以冒号隔开，而不是分号</p><blockquote><p>配置完成，退出编辑框后</p><p>source  ~/.hash_profile</p></blockquote><h4 id="4、测试："><a href="#4、测试：" class="headerlink" title="4、测试："></a>4、测试：</h4><blockquote><p>java  -version</p><p>或</p><p>echo  $JAVA_HOME</p></blockquote><p><code>echo   标准输出，打印</code></p><h3 id="六、Tomcat部署"><a href="#六、Tomcat部署" class="headerlink" title="六、Tomcat部署"></a>六、Tomcat部署</h3><h4 id="1、官网下载"><a href="#1、官网下载" class="headerlink" title="1、官网下载"></a>1、官网下载</h4><p><a href="http://tomcat.apache.org/" target="_blank" rel="noopener">http://tomcat.apache.org/</a></p><p>云盘资源：<a href="https://pan.baidu.com/s/1e7OSIf3K9YpFCzXncMj_9Q" target="_blank" rel="noopener">apache-tomcat-7.0.61.tar</a></p><h4 id="2、上传并解压"><a href="#2、上传并解压" class="headerlink" title="2、上传并解压"></a>2、上传并解压</h4><blockquote><p>tar -zvxf  apache-tomcat-7.0.61.tar</p></blockquote><h4 id="3、启动tomcat"><a href="#3、启动tomcat" class="headerlink" title="3、启动tomcat"></a>3、启动tomcat</h4><p>在tomcat的bin目录下有个startup.sh 脚本可以直接启动tomcat服务</p><blockquote><p>./startup.sh</p></blockquote><h4 id="4、关闭tomcat服务"><a href="#4、关闭tomcat服务" class="headerlink" title="4、关闭tomcat服务"></a>4、关闭tomcat服务</h4><p>方式一：可以用shutdown.sh命令</p><p>方式二：ps -ef | grep tomcat 查看出tomcat进程号后，用kill命令</p><h4 id="5、验证"><a href="#5、验证" class="headerlink" title="5、验证"></a>5、验证</h4><p>先把防火墙关了（service iptables stop），然后访问虚拟机IP的8080端口</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>单例设计模式</title>
      <link href="/2019/01/25/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/01/25/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p># </p><h3 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h3><h4 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h4><p>:一个类只能创建一个对象</p><ol><li>私有化构造器</li><li>在类的内部创建一个类的实例,且为static</li><li>私有化对象,通过公共方法调用</li><li>此公共方法只能通过类来调用,因为设置的是static,同时类的实例也是static</li></ol><p>饿汉先创建好:</p><pre><code>    package bank;    public class TestSingleton {        public static void main (String[] args){                Singleton s1 = Singleton.getInstance();                Singleton s2 = Singleton.getInstance();                System.out.println(s1 == s2); //true        }    }    class Singleton{        //1.私有化构造器        private Singleton(){        }        //2.在类中创建一个类的实例,私有化,静态的        private static Singleton instance = new Singleton();        // 3.通过公共方法调用,此公共方法只能类调用,因为设置了 static        public static Singleton getInstance(){            return instance;        }    }</code></pre><h4 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h4><ol><li>私有化构造器</li><li>创建一个私有的实例static 先不实例化 为 null</li><li><p>通过公共方法调用 static 在方法里面进行判断,if = null<br>实例化 !=null 直接return</p><pre><code>class Singleton{        //1.私有化构造器        private Singleton(){}        //2.创建一个私有的实例为static 且值设置为null    private static Singleton instance = null;        //3.通过公共方法调用,static    public static Singleton getInstance(){        if (instance == null){            instance = new Singleton();        }        return instance;    }}</code></pre></li></ol><p>懒汉式:用的时候创建</p><p>懒汉式:可能出现线程安全问题,</p><pre><code>public class SingleDemo {    private static SingleDemo s = null;    private SingleDemo(){}    public static  SingleDemo getInstance(){        /*如果第一个线程获取到了单例的实例对象，         * 后面的线程再获取实例的时候不需要进入同步代码块中了*/        if(s == null){            //同步代码块用的锁是单例的字节码文件对象，且只能用这个锁            synchronized(SingleDemo.class){                if(s == null){                    s = new SingleDemo();                }            }        }        return s;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> HelloWorld </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring中bean的作用域</title>
      <link href="/2019/01/16/%E5%85%B3%E4%BA%8ESpring%E4%B8%ADbean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
      <url>/2019/01/16/%E5%85%B3%E4%BA%8ESpring%E4%B8%ADbean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p># </p><h2 id="一、bean的四种作用域"><a href="#一、bean的四种作用域" class="headerlink" title="一、bean的四种作用域"></a>一、bean的四种作用域</h2><p>Spring定义了多种作用域，可以基于这些作用域创建bean，包括:</p><pre><code>单例（Singleton）：在整个应用中，只创建bean的一个实例。原型（Prototype）：每次注入或者通过Spring应用上下文获取的时候，都会创建一个新的bean实例。会话（Session）：在Web应用中，为每个会话创建一个bean实例。请求（Rquest）：在Web应用中，为每个请求创建一个bean实例 </code></pre><p>在默认情况下， Spring应用上下文中所有bean都是作为以单例（singleton）的形式创建的。也就是说，不管给定的一个bean被注入到其他bean多少次，每次所注入的都是同一个实例。在大多数情况下，单例bean是很理想的方案。但是在某些情况下，你所使用的类是易变的（mutable），它们会保持一些状态，因此重用是不安全的。在这种情况下，将class声明为单例的bean就不是什么好主意了。</p><h2 id="二、使用其他作用域的bean"><a href="#二、使用其他作用域的bean" class="headerlink" title="二、使用其他作用域的bean"></a>二、使用其他作用域的bean</h2><p>要声明bean为其他作用域，可以使用@Scope注解，以下是用过@Scope注解和@Component注解一起使用，声明了一个原型作用域的bean：</p><pre><code>@Component@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)public class Notepad{...}</code></pre><p>这里，使用ConfigurableBeanFactory类的<code>SCOPE_PROTOTYPE</code>常量设置了原型作用域。你当然也可以使用@Scope(“prototype”)，但是使用<code>SCOPE_PROTOTYPE</code>常量更加安全并且不易出错。</p><p>同样，@Scope注解也可以和@Bean注解一起使用:</p><pre><code>@Bean@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)public Notepad notepad(){    return new Notepad();}</code></pre><p>同样，可以使用scope属性通过XML的方式配置其他作用域的bean:</p><pre><code>&lt;bean id=&quot;notepad&quot; class=&quot;com.carleviets.Notepad&quot; scope=&quot;prototype&quot;/&gt;</code></pre><h2 id="三、使用会话和请求作用域"><a href="#三、使用会话和请求作用域" class="headerlink" title="三、使用会话和请求作用域"></a>三、使用会话和请求作用域</h2><p>在典型的电子商务应用中，可能会有一个bean代表用户的购物车。如果购物车是单例的话，那么将会导致所有的用户都会向同一个购物车中添加商品。另一方面，如果购物车是原型作用域的，那么在应用中某一个地方往购物车中添加商品，在应用的另外一个地方可能就不可用了。就购物车bean来说，会话作用域是最为合适的，因为它与给定的用户关联性最大。</p><pre><code>@Component@Scope(value=WebApplicationContext.SCOPE_SESSION, proxyMode=ScopedProxyMode.INTERFACES)public class ShoppingCart{...}</code></pre><p>注意,@Scope同时还有一个proxyMode属性，它被设置成了ScopedProxyMode.INTERFACES。这个属性解决了将会话或请求作用域的bean注入到单例bean中所遇到的问题。例如，如下的StoreService bean表示在线商店提供的服务:</p><pre><code>@Componentpublic class StoreService{    private ShoppingCart shoppingCart;    @Autowired    public void setShoppingCart(ShoppingCart shoppingCart){        this.shoppingCart=shoppingCart;    }    ...}</code></pre><p>因为StoreService是一个单例的bean，会在Spring应用上下文加载的时候创建。当它创建的时候， Spring会试图将ShoppingCart bean注入到setShoppingCart()方法中。但是ShoppingCart bean是会话作用域的，此时并不存在。直到某个用户进入系统，创建了会话之后，才会出现ShoppingCart实例。</p><p>如果使用了proxyMode=ScopedProxyMode.INTERFACES的话，Spring并不会将实际的ShoppingCart bean注入到StoreService中，而是会注入一个到ShoppingCart bean的代理，如图所示。这个代理会暴露与ShoppingCart相同的方法，所以StoreService会认为它就是一个购物车。但是，当StoreService调用ShoppingCart的方法时，代理会对其进行懒解析并将调用委托给会话作用域内真正的ShoppingCart bean。</p><p><img src="http://wx1.sinaimg.cn/mw690/0060lm7Tly1fz6igknkjlj30r00dy78f.jpg" alt="avatar"></p><p>这是使用的是Spring基于接口的代理，但如果ShoppingCart是一个具体的类的话，Spring就没有办法创建基于接口的代理了。此时，它必须使用CGLib来生成基于类的代理。所以，如果bean类型是具体类的话，我们必须要将proxyMode属性设置为ScopedProxyMode.TARGET_CLASS，以此来表明要以生成目标类扩展的方式创建代理。</p><p>尽管这里主要关注了会话作用域，但是请求作用域的bean会面临相同的装配问题。因此，请求作用域的bean应该也以作用域代理的方式进行注入。</p>]]></content>
      
      
      <categories>
          
          <category> HelloWorld </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typora-vue-theme Theme introduction</title>
      <link href="/2018/09/07/hello-world/"/>
      <url>/2018/09/07/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> HelloWorld </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
